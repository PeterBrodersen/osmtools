<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wikidata Auto</title>
    <script>
        const locations = {
            "Q515": "City",
            "Q2983893": "City quarter",
            "Q188509": "Suburb",
            "Q3957": "Town",
            "Q532": "Village",
            "Q5084": "Hamlet",
            "Q486972": "Human Settlement",
            "Q12336407": "Holiday home area",
            "Q54050": "Hill",
            "Q131596": "Farm",
            "Q12280": "Bridge",
            "Q1681353": "Bog",
            "Q188869": "Field",
            "Q7777019": "Meadow",
            "Q41176": "Building",
            "Q3947": "House",
            "Q879050": "Manor house",
            "Q1371789": "Summer house",
            "Q38720": "Windmill",
            "Q4421": "Forest",
            "Q23397": "Lake",
            "Q40080": "Beach",
            "Q22698": "Park",
            "Q16970": "Church",
            "Q2221906": "Geographic location",
        };

        const occupations = {
            "": "Select Occupation",
            "Q82955": "Politician",
            "Q42855995": "Fabricator",
            "Q331432": "Fisher",
            "Q1897112": "Skipper",
            "Q78597495": "Strandfoged",
            "Q37226": "Teacher",
            "Q61743173": "Vognmand",
            "Q39631": "Doctor",
            "Q131512": "Farmer",
        };

        const municipalities = {
            "": "Select Municipality",
            "Q493833": "Albertslund",
            "Q499479": "AllerÃ¸d",
            "Q27967": "Assens",
            "Q257223": "Ballerup",
            "Q27875": "Billund",
            "Q2598329": "Bornholm",
            "Q484038": "BrÃ¸ndby",
            "Q511376": "BrÃ¸nderslev",
            "Q504125": "Copenhagen",
            "Q838823": "DragÃ¸r",
            "Q505113": "Egedal",
            "Q645747": "Esbjerg",
            "Q493285": "FanÃ¸",
            "Q512550": "Favrskov",
            "Q505000": "Faxe",
            "Q503045": "Fredensborg",
            "Q21145": "Fredericia",
            "Q2488464": "Frederiksberg",
            "Q502168": "Frederikshavn",
            "Q503232": "Frederikssund",
            "Q503138": "FuresÃ¸",
            "Q27976": "Faaborg-Midtfyn",
            "Q500076": "Gentofte",
            "Q484018": "Gladsaxe",
            "Q21006": "Glostrup",
            "Q504977": "Greve",
            "Q494827": "Gribskov",
            "Q510997": "Guldborgsund",
            "Q21143": "Haderslev",
            "Q505130": "HalsnÃ¦s",
            "Q515986": "Hedensted",
            "Q511546": "HelsingÃ¸r",
            "Q164490": "Herlev",
            "Q506877": "Herning",
            "Q221394": "HillerÃ¸d",
            "Q511214": "HjÃ¸rring",
            "Q503159": "HolbÃ¦k",
            "Q506109": "Holstebro",
            "Q512064": "Horsens",
            "Q512562": "Hvidovre",
            "Q499400": "HÃ¸je-Taastrup",
            "Q512540": "HÃ¸rsholm",
            "Q512595": "Ikast-Brande",
            "Q502040": "IshÃ¸j",
            "Q503222": "Jammerbugt",
            "Q204976": "Kalundborg",
            "Q612488": "Kerteminde",
            "Q21101": "Kolding",
            "Q504664": "KÃ¸ge",
            "Q506647": "Langeland",
            "Q505369": "Lejre",
            "Q502644": "Lemvig",
            "Q670153": "Lolland",
            "Q493826": "Lyngby-TaarbÃ¦k",
            "Q498457": "LÃ¦sÃ¸",
            "Q512528": "Mariagerfjord",
            "Q21140": "Middelfart",
            "Q502770": "MorsÃ¸",
            "Q505156": "Norddjurs",
            "Q20770": "Nordfyns",
            "Q30013": "Nyborg",
            "Q506716": "NÃ¦stved",
            "Q500058": "Odder",
            "Q21146": "Odense",
            "Q1425064": "Odsherred",
            "Q512457": "Randers",
            "Q499896": "Rebild",
            "Q514777": "RingkÃ¸bing-Skjern",
            "Q503116": "Ringsted",
            "Q510810": "Roskilde",
            "Q511949": "Rudersdal",
            "Q503097": "RÃ¸dovre",
            "Q513256": "SamsÃ¸",
            "Q505151": "Silkeborg",
            "Q7725510": "Skanderborg",
            "Q503108": "Skive",
            "Q29927": "Slagelse",
            "Q499469": "SolrÃ¸d",
            "Q21151": "SorÃ¸",
            "Q503153": "Stevns",
            "Q503227": "Struer",
            "Q21182": "Svendborg",
            "Q512581": "Syddjurs",
            "Q21108": "SÃ¸nderborg",
            "Q7715809": "Thisted",
            "Q3162907": "TÃ¸nder",
            "Q282496": "TÃ¥rnby",
            "Q514844": "VallensbÃ¦k",
            "Q21142": "Varde",
            "Q21150": "Vejen",
            "Q28150": "Vejle",
            "Q511975": "Vesthimmerlands",
            "Q502962": "Viborg",
            "Q183572": "Vordingborg",
            "Q21104": "Ã†rÃ¸",
            "Q21152": "Aabenraa",
            "Q300856": "Aalborg",
            "Q240262": "Aarhus"
        }

        const positionsHeld = {
            "": "Select Position",
            "Q30185": "Mayor",
            "Q708492": "Council member",
            "Q12336313": "Sognefoged",
            "Q5004082": "Byfoged",
            "Q19702908": "SognerÃ¥dsformand",
            "Q127121956": "SognerÃ¥dsmedlem",
        };

        function formatDate(date) {
            date = date.trim();
            if (!date) return '';
            let precision = 9; // Default precision is year

            // Allow spaces and multiple delimiters between day, month, year
            // Match: 1-2 digits, delimiter(s), 1-2 digits, delimiter(s), 4 digits
            let dmyMatch = date.match(/^(\d{1,2})[\s\-\/\.]+(\d{1,2})[\s\-\/\.]+(\d{4})$/);
            if (dmyMatch) {
                let day = dmyMatch[1].padStart(2, '0');
                let month = dmyMatch[2].padStart(2, '0');
                let year = dmyMatch[3];
                precision = 11;
                date = `+${year}-${month}-${day}T00:00:00Z`;
            } else if (date.match(/^\d{4}$/)) {
                precision = 9;
                date = `+${date}-00-00T00:00:00Z`;
            } else if (date.match(/^\d{4}-\d{2}$/)) {
                precision = 10;
                date = `+${date}-00T00:00:00Z`;
            } else if (date.match(/^\d{4}-\d{2}-\d{2}$/)) {
                precision = 11;
                date = `+${date}T00:00:00Z`;
            }
            return `${date}/${precision}`;
        }

        // Parse a coordinates string into an object {lat, lng} or return false if invalid.
        function parseCoordinates(str) {
            if (!str || typeof str !== 'string') {
                try { document.getElementById('municipalityName').textContent = ''; } catch (e) { }
                return false;
            }
            str = str.trim();
            // Count commas
            const commaCount = (str.match(/,/g) || []).length;
            // Case A: three commas used as decimal separators, e.g. "12,34, 56,78"
            if (commaCount === 3) {
                const parts = str.split(',');
                if (parts.length === 4) {
                    const lat = parts[0].trim() + '.' + parts[1].trim();
                    const lng = parts[2].trim() + '.' + parts[3].trim();
                    if (!isFinite(lat) || !isFinite(lng)) return false;
                    // Trigger municipality lookup (fire-and-forget) - pass x=longitude, y=latitude
                    try { lookupMunicipality(parseFloat(lng), parseFloat(lat)); } catch (e) { }
                    return { lat: lat, lng: lng };
                }
                // clear municipality display when invalid
                try { document.getElementById('municipalityName').textContent = ''; } catch (e) { }
                return false;
            }
            // Case B: standard "lat,lng" (one comma)
            if (commaCount === 1) {
                const parts = str.split(',');
                if (parts.length === 2) {
                    const lat = parts[0].trim();
                    const lng = parts[1].trim();
                    if (!lat || !lng || !isFinite(lat) || !isFinite(lng)) return false;
                    try { lookupMunicipality(parseFloat(lng), parseFloat(lat)); } catch (e) { }
                    return { lat: lat, lng: lng };
                }
                try { document.getElementById('municipalityName').textContent = ''; } catch (e) { }
                return false;
            }
            // Anything else is invalid
            try { document.getElementById('municipalityName').textContent = ''; } catch (e) { }
            return false;
        }

        // Format a {lat, lng} object into QuickStatements string "@lat/lng" or return false.
        function formatCoordinatesQS(coordObj) {
            if (!coordObj || typeof coordObj !== 'object') return false;
            if (!('lat' in coordObj) || !('lng' in coordObj)) return false;
            const lat = coordObj.lat;
            const lng = coordObj.lng;
            if (!isFinite(lat) || !isFinite(lng)) return false;
            return `@${lat}/${lng}`;
        }

        function getSourceStatement(source) {
            if (!source) return '';
            source = source.trim();
            if (source.match(/^Q\d+$/)) { // Wikidata item ID
                return `|S248|${source}`;
            } else if (source.match(/^geni\s+(\d+)$/i)) { // Geni ID
                const geniId = source.match(/^geni\s+(\d+)$/i)[1];
                return `|S2600|"${geniId}"`;
            } else if (source.match(/^gravsted\s+(.+)$/i)) { // Gravsted ID
                const gravstedId = source.match(/^gravsted\s+(.+)$/i)[1];
                return `|P4359|"${gravstedId}"`;
            } else { // URL or other source
                return `|S854|"${source}"`;
            }
        }

        let firstNameItems = [];
        let surnameItems = [];

        let lookupTimers = { firstName: null, surname: null };
        let lookupTokens = { firstName: '', surname: '' };
        let labelLookupToken = '';
        // Guards to prevent recursive or repeated municipality lookups
        let skipMunicipalityLookup = false;
        let lastMunicipalityCoords = null; // {x,y}

        function lookupNameParts(type) {
            let input = document.getElementById(type).value.trim();
            let token = input.toLowerCase();
            lookupTokens[type] = token;
            if (lookupTimers[type]) clearTimeout(lookupTimers[type]);
            lookupTimers[type] = setTimeout(() => {
                doLookupNameParts(type, input, token);
            }, 300);
        }

        // Lookup exact label on Wikidata and show result/link
        async function lookupLabelExact() {
            try {
                const label = document.getElementById('label').value.trim();
                const out = document.getElementById('labelLookup');
                if (!label) {
                    if (out) out.innerHTML = '';
                    return;
                }
                const token = label.toLowerCase();
                labelLookupToken = token;

                // SPARQL: match exact rdfs:label in Danish/English/multilingual
                const sparql = `SELECT DISTINCT ?item ?itemLabel ?desc WHERE {\n  VALUES ?lbl { "${label}"@da "${label}"@en "${label}"@mul }\n  ?item rdfs:label ?lbl.\n  OPTIONAL { ?item schema:description ?desc. FILTER(lang(?desc) = "da" || lang(?desc) = "en") }\n  SERVICE wikibase:label { bd:serviceParam wikibase:language "da,en". }\n} LIMIT 50`;
                const url = 'https://query.wikidata.org/sparql?format=json&query=' + encodeURIComponent(sparql);
                const resp = await fetch(url);
                // If user changed input while fetching, abort showing results
                if (labelLookupToken !== token) return;
                if (!resp.ok) {
                    if (out) out.innerHTML = `<a href="https://www.wikidata.org/w/index.php?search=${encodeURIComponent(label)}" target="_blank">Search Wikidata for ${escapeHtml(label)}</a>`;
                    return;
                }
                const data = await resp.json();
                if (labelLookupToken !== token) return;
                const bindings = data.results.bindings;
                if (!bindings || bindings.length === 0) {
                    if (out) out.innerHTML = `<a href="https://www.wikidata.org/w/index.php?search=${encodeURIComponent(label)}" target="_blank">No exact match found â€” search Wikidata for ${escapeHtml(label)}</a>`;
                } else if (bindings.length === 1) {
                    const b = bindings[0];
                    const itemUrl = b.item.value;
                    const itemId = itemUrl.split('/').pop();
                    const itemLabel = b.itemLabel ? b.itemLabel.value : label;
                    const desc = b.desc ? b.desc.value : '';
                    if (out) out.innerHTML = `<a href="https://www.wikidata.org/wiki/${itemId}" target="_blank">${escapeHtml(itemLabel)}</a>${desc ? ' â€” ' + escapeHtml(desc) : ''}`;
                } else {
                    if (out) out.innerHTML = `<a href="https://www.wikidata.org/w/index.php?search=${encodeURIComponent(label)}" target="_blank">${bindings.length} exact matches found on Wikidata â€” search for ${escapeHtml(label)}</a>`;
                }
            } catch (err) {
                try { document.getElementById('labelLookup').innerHTML = ''; } catch (e) { }
            }
        }

        async function doLookupNameParts(type, input, token) {
            let words = input.split(/\s+/).filter(Boolean);
            let resultsDiv = document.getElementById(type + 'Results');
            resultsDiv.innerHTML = '';
            if (words.length === 0) {
                if (type === 'firstName') firstNameItems = [];
                if (type === 'surname') surnameItems = [];
                updateQuickStatements();
                return;
            }
            let items = [];
            for (let i = 0; i < words.length; i++) {
                let word = words[i];
                let sparql = '';
                if (type === 'firstName') {
                    sparql = `SELECT ?item ?itemLabel WHERE {
                        ?item rdfs:label ?lbl.
                        VALUES ?lbl { "${word}"@da "${word}"@en "${word}"@mul }
                        ?item rdfs:label ?lbl.
                        ?item wdt:P31 ?type.
                        VALUES ?type { wd:Q202444 wd:Q12308941 wd:Q11879590 wd:Q3409032 }
                        SERVICE wikibase:label { bd:serviceParam wikibase:language "da,en,mul". }
                    } LIMIT 1`;
                } else {
                    sparql = `SELECT ?item ?itemLabel WHERE {
                        VALUES ?lbl { "${word}"@da "${word}"@en "${word}"@mul }
                        ?item rdfs:label ?lbl.
                        ?item wdt:P31 wd:Q101352.
                        SERVICE wikibase:label { bd:serviceParam wikibase:language "da,en,mul". }
                    } LIMIT 1`;
                }
                let url = 'https://query.wikidata.org/sparql?format=json&query=' + encodeURIComponent(sparql);
                let response = await fetch(url);
                // Check if the input has changed since the request was sent
                if (lookupTokens[type] !== token) return;
                let data = await response.json();
                if (data.results.bindings.length > 0) {
                    let item = data.results.bindings[0].item.value;
                    let itemId = item.split('/').pop();
                    let label = data.results.bindings[0].itemLabel.value;
                    items.push({ id: itemId, label });
                } else {
                    items.push({ id: null, label: word });
                }
            }
            // Check again before updating results
            if (lookupTokens[type] !== token) return;
            let html = words.map((w, i) => {
                let item = items[i];
                if (item.id) {
                    return `<a href="https://www.wikidata.org/wiki/${item.id}" target="_blank">${item.label}</a>`;
                } else {
                    return `<span>${item.label}</span>`;
                }
            }).join(' ');
            resultsDiv.innerHTML = html;
            if (type === 'firstName') firstNameItems = items;
            if (type === 'surname') surnameItems = items;
            if (document.getElementById('type').value === 'Human') {
                updateQuickStatements();
            }
        }

        function updateQuickStatements() {
            let type = document.getElementById('type').value;
            let subType = document.getElementById('subType').value;
            let birthDate = formatDate(document.getElementById('birthDate').value);
            let deathDate = formatDate(document.getElementById('deathDate').value);
            let citizenship = document.getElementById('citizenship').checked ? 'Q756617' : '';
            let source = getSourceStatement(document.getElementById('source').value);
            let label = document.getElementById('label').value;
            let description = document.getElementById('description').value;
            let alias = document.getElementById('alias').value;
            let occupation = document.getElementById('occupation').value;
            let positionHeld = document.getElementById('positionHeld').value;
            let positionStart = document.getElementById('positionStart').value;
            let positionEnd = document.getElementById('positionEnd').value;
            let country = document.getElementById('country').checked ? 'Q35' : '';
            let municipality = document.getElementById('municipality').value;
            // Parse coordinates and format for QuickStatements
            let coordObj = parseCoordinates(document.getElementById('coordinates').value);
            let coordinates = coordObj ? formatCoordinatesQS(coordObj) : '';
            let osmNode = document.getElementById('osmNode').value;
            let osmWay = document.getElementById('osmWay').value;
            let osmRelation = document.getElementById('osmRelation').value;
            let address = document.getElementById('address').value;

            // Show/hide positionHeldDates
            if (type === 'Human' && positionHeld) {
                document.getElementById('positionHeldDates').style.display = 'block';
            } else {
                document.getElementById('positionHeldDates').style.display = 'none';
            }

            let quickStatements = 'CREATE\n';

            if (type === 'Human') {
                quickStatements += 'LAST|P31|Q5\n';
                if (subType === 'Man') {
                    quickStatements += 'LAST|P21|Q6581097\n';
                } else if (subType === 'Woman') {
                    quickStatements += 'LAST|P21|Q6581072\n';
                }
                if (birthDate) {
                    quickStatements += `LAST|P569|${birthDate}${source}\n`;
                }
                if (deathDate) {
                    quickStatements += `LAST|P570|${deathDate}${source}\n`;
                }
                if (citizenship) {
                    quickStatements += `LAST|P27|${citizenship}\n`;
                }
                if (occupation) {
                    quickStatements += `LAST|P106|${occupation}${source}\n`;
                }
                if (positionHeld) {
                    quickStatements += `LAST|P39|${positionHeld}`;
                    let start = formatDate(positionStart);
                    let end = formatDate(positionEnd);
                    if (start && start !== '+-00-00T00:00:00Z/9') quickStatements += `|P580|${start}`;
                    if (end && end !== '+-00-00T00:00:00Z/9') quickStatements += `|P582|${end}`;
                    quickStatements += `${source}\n`;
                }
                // Add given names (P735) and family names (P734) from lookup ONLY for Human
                if (firstNameItems.length > 0) {
                    firstNameItems.forEach((item, idx) => {
                        if (item.id) {
                            if (firstNameItems.length > 1) {
                                quickStatements += `LAST|P735|${item.id}|P1545|"${idx + 1}"\n`;
                            } else {
                                quickStatements += `LAST|P735|${item.id}\n`;
                            }
                        }
                    });
                }
                if (surnameItems.length > 0) {
                    surnameItems.forEach((item, idx) => {
                        if (item.id) {
                            if (surnameItems.length > 1) {
                                quickStatements += `LAST|P734|${item.id}|P1545|"${idx + 1}"\n`;
                            } else {
                                quickStatements += `LAST|P734|${item.id}\n`;
                            }
                        }
                    });
                }
            } else if (type === 'Location') {
                if (subType) {
                    quickStatements += `LAST|P31|${subType}\n`;
                }
                if (country) {
                    quickStatements += `LAST|P17|${country}\n`;
                }
                if (municipality) {
                    quickStatements += `LAST|P131|${municipality}\n`;
                }
                if (address) {
                    quickStatements += `LAST|P6375|da:"${address}"\n`;
                }
                // Elevation for Hill (P2044) in meters (unit Q11573)
                try {
                    let elevationVal = document.getElementById('elevation') ? document.getElementById('elevation').value.trim() : '';
                    if (subType === 'Q54050' && elevationVal) {
                        // QuickStatements quantity with unit: +<value>/9 and then unit as S<item>
                        // Using the user's requested pattern: LAST|P2044|+<value>/9|S11573
                        let cleaned = elevationVal.replace(',', '.');
                        if (isFinite(cleaned)) {
                            quickStatements += `LAST|P2044|${cleaned}U11573\n`;
                        }
                    }
                } catch (e) { }
                if (coordinates) {
                    quickStatements += `LAST|P625|${coordinates}\n`;
                }
                if (osmNode) {
                    quickStatements += `LAST|P11693|"${osmNode}"\n`;
                }
                if (osmWay) {
                    quickStatements += `LAST|P10689|"${osmWay}"\n`;
                }
                if (osmRelation) {
                    quickStatements += `LAST|P402|"${osmRelation}"\n`;
                }
            } else if (type === 'Name') {
                if (subType === 'Surname') {
                    quickStatements += 'LAST|P31|Q101352\n';
                } else if (subType === 'First name') {
                    quickStatements += 'LAST|P31|Q202444\n';
                } else if (subType === 'First name (male)') {
                    quickStatements += 'LAST|P31|Q12308941\n';
                } else if (subType === 'First name (female)') {
                    quickStatements += 'LAST|P31|Q11879590\n';
                }
                quickStatements += 'LAST|P282|Q8229\n';
                if (label) {
                    quickStatements += `LAST|P1705|da:"${label}"\n`;
                }
            }

            if (label) {
                quickStatements += `LAST|Lda|"${label}"\n`;
            }
            if (description) {
                quickStatements += `LAST|Dda|"${description}"\n`;
            }
            if (alias) {
                alias.split('|').forEach(a => {
                    if (a.trim()) {
                        quickStatements += `LAST|Ada|"${a.trim()}"\n`;
                    }
                });
            }

            document.getElementById('quickStatements').value = quickStatements;
            updateQuickStatementsLink(quickStatements);

            // Show OSM link if coordinates are valid
            var osmLinkDiv = document.getElementById('osmCoordinateLink');
            if (osmLinkDiv) {
                if (coordObj) {
                    var lat = coordObj.lat;
                    var lng = coordObj.lng;
                    var url = `https://www.openstreetmap.org/query?lat=${lat}&lon=${lng}`;
                    osmLinkDiv.innerHTML = `<a href="${url}" target="_blank">View on OpenStreetMap</a>`;
                } else {
                    osmLinkDiv.innerHTML = '';
                }
            }
        }

        function updateQuickStatementsLink(quickStatements) {
            let encodedStatements = encodeURIComponent(quickStatements).replace(/%0A/g, '%7C%7C');
            let quickStatementsLink = `https://quickstatements.toolforge.org/#/v1=${encodedStatements}`;
            document.getElementById('quickStatementsLink').href = quickStatementsLink;
        }

        function updateSubTypeOptions() {
            let type = document.getElementById('type').value;
            let subType = document.getElementById('subType');
            subType.innerHTML = '';

            if (type === 'Human') {
                subType.innerHTML += '<option value="Man">Man</option>';
                subType.innerHTML += '<option value="Woman">Woman</option>';
                document.getElementById('humanFields').style.display = 'block';
                document.getElementById('locationFields').style.display = 'none';
            } else if (type === 'Location') {
                for (let key in locations) {
                    subType.innerHTML += `<option value="${key}">${locations[key]}</option>`;
                }
                document.getElementById('humanFields').style.display = 'none';
                document.getElementById('locationFields').style.display = 'block';
                document.getElementById('elevationField').style.display = (subType.value === 'Q54050') ? 'block' : 'none';
            } else if (type === 'Name') {
                subType.innerHTML += '<option value="Surname">Surname</option>';
                subType.innerHTML += '<option value="First name">First name</option>';
                subType.innerHTML += '<option value="First name (male)">First name (male)</option>';
                subType.innerHTML += '<option value="First name (female)">First name (female)</option>';
                document.getElementById('humanFields').style.display = 'none';
                document.getElementById('locationFields').style.display = 'none';
            }
            updateSubtypeUI();
            updateSubTypeSuggestion();
            updateQuickStatements();
        }

        // Suggest a subtype based on words found in the description.
        function updateSubTypeSuggestion() {
            try {
                const desc = (document.getElementById('description').value || '').toLowerCase();
                const suggestionEl = document.getElementById('subTypeSuggestion');
                if (!suggestionEl) return;

                const map = [
                    { key: 'gÃ¥rd', label: 'Farm', q: 'Q131596' },
                    { key: 'landsby', label: 'Hamlet', q: 'Q5084' },
                    { key: 'mÃ¸lle', label: 'Windmill', q: 'Q38720' },
                    { key: 'skov', label: 'Forest', q: 'Q4421' },
                    { key: 'bakke', label: 'Hill', q: 'Q54050' },
                    { key: 'mose', label: 'Bog', q: 'Q1681353' },
                    { key: 'sÃ¸',   label: 'Lake', q: 'Q23397' },
                    { key: 'kirke', label: 'Church', q: 'Q16970' },
                    { key: 'bro',  label: 'Bridge', q: 'Q12280' },
                    { key: 'strand', label: 'Beach', q: 'Q40080' }
                ];

                // Only first match counts; order matters (e.g. 'gÃ¥rd' before 'sÃ¸')
                let found = null;
                for (let i = 0; i < map.length; i++) {
                    if (desc.indexOf(map[i].key) !== -1) { found = map[i]; break; }
                }

                if (found) {
                    suggestionEl.classList.remove('hidden');
                    suggestionEl.dataset.q = found.q;
                    suggestionEl.innerHTML = `Suggestion: <a href="#" accesskey="s" onclick="applySubTypeSuggestion('${found.q}'); return false;">${found.label}</a>`;
                } else {
                    suggestionEl.classList.add('hidden');
                    delete suggestionEl.dataset.q;
                    suggestionEl.innerHTML = '';
                }
            } catch (e) { }
        }

        function applySubTypeSuggestion(q) {
            try {
                const subType = document.getElementById('subType');
                if (!subType) return;
                subType.value = q;
                updateSubtypeUI();
                updateQuickStatements();
            } catch (e) { }
        }

        // Set the selected Type (keeps hidden #type in sync for existing code)
        function setType(value) {
            try {
                // Update hidden input used by existing code
                const hidden = document.getElementById('type');
                if (hidden) hidden.value = value;

                // Check the underlying radio input
                const radio = document.getElementById('type_' + value);
                if (radio) radio.checked = true;

                // Update visual selected state
                document.querySelectorAll('.type-buttons .btn').forEach(b => b.classList.remove('selected'));
                const lab = document.querySelector('.type-buttons label[for="type_' + value + '"]');
                if (lab) lab.classList.add('selected');

                // Trigger the same onchange behavior
                updateSubTypeOptions();
            } catch (e) { }
        }

        // Toggle UI elements that depend on the selected subtype
        function updateSubtypeUI() {
            try {
                var subTypeEl = document.getElementById('subType');
                var elevationField = document.getElementById('elevationField');
                var subWarning = document.getElementById('subTypeWarning');
                var addressEl = document.getElementById('address');
                if (subTypeEl && elevationField) {
                    elevationField.style.display = (subTypeEl.value === 'Q54050') ? 'block' : 'none';
                }
                if (subWarning) {
                    var typeEl = document.getElementById('type');
                    var cityTypes = ['Q515','Q2983893','Q188509','Q3957','Q532','Q5084','Q486972','Q12336407'];
                    var isCity = subTypeEl && cityTypes.indexOf(subTypeEl.value) !== -1 && typeEl && typeEl.value === 'Location';
                    var hasAddress = addressEl && addressEl.value && addressEl.value.trim() !== '';
                    if (isCity && hasAddress) {
                        subWarning.textContent = 'âš  Address not allowed for City';
                        subWarning.title = 'City subtype should not have an address';
                    } else {
                        subWarning.textContent = '';
                        subWarning.title = '';
                    }
                }
            } catch (e) { }
        }

        // Debounced fetch for OSM element name tag
        const osmFetchTimers = { node: null, way: null, relation: null };

        function scheduleFetchOSM(type) {
            try {
                if (osmFetchTimers[type]) clearTimeout(osmFetchTimers[type]);
                osmFetchTimers[type] = setTimeout(() => fetchOSMElementName(type), 300);
            } catch (e) { }
        }

        async function fetchOSMElementName(type) {
            try {
                const id = document.getElementById('osm' + capitalize(type)).value.trim();
                const resultDiv = document.getElementById('osm' + capitalize(type) + 'Name');
                if (!id) {
                    if (resultDiv) resultDiv.textContent = '';
                    return;
                }
                // Basic validation: id should be digits
                if (!/^\d+$/.test(id)) {
                    if (resultDiv) resultDiv.textContent = 'Invalid ID';
                    return;
                }
                const url = `https://api.openstreetmap.org/api/0.6/${type}/${id}`;
                const resp = await fetch(url);
                if (!resp.ok) {
                    if (resultDiv) resultDiv.textContent = `OSM ${type} not found`;
                    return;
                }
                const text = await resp.text();
                // parse minimal XML to find tag k="name"
                const parser = new DOMParser();
                const xml = parser.parseFromString(text, 'application/xml');
                const elem = xml.querySelector(type);
                if (!elem) {
                    if (resultDiv) resultDiv.textContent = '';
                    return;
                }
                const nameTag = elem.querySelector('tag[k="name"]');
                if (nameTag) {
                    const name = nameTag.getAttribute('v');
                    if (resultDiv) {
                        // Link the name to the OpenStreetMap element page and keep the load-from-OSM emoji button
                        const osmUrl = encodeURI(`https://www.openstreetmap.org/${type}/${id}`);
                        resultDiv.innerHTML = `OSM name: <a href="${osmUrl}" target="_blank">${escapeHtml(name)}</a> <a href="#" onclick="loadFromOSM('${type}'); return false;" title="Load from OSM data">ðŸ“¥</a>`;
                    }
                } else {
                    if (resultDiv) {
                        const osmUrl = encodeURI(`https://www.openstreetmap.org/${type}/${id}`);
                        resultDiv.innerHTML = `<a href="${osmUrl}" target="_blank">OSM ${type} ${escapeHtml(id)} (no name tag)</a> <a href="#" onclick="loadFromOSM('${type}'); return false;" title="Load from OSM data">ðŸ“¥</a>`;
                    }
                }
            } catch (err) {
                // swallow network errors silently
            }
        }

        function capitalize(s) { return s.charAt(0).toUpperCase() + s.slice(1); }

        function escapeHtml(str) {
            return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
        }
        // Lookup Danish municipality by coordinates using Dataforsyningen reverse endpoint
        async function lookupMunicipality(x, y) {
            try {
                // Prevent recursive re-entry from updateQuickStatements
                if (skipMunicipalityLookup) return;
                if (!isFinite(x) || !isFinite(y)) {
                    document.getElementById('municipalityName').textContent = '';
                    return;
                }
                // Avoid refetching for the same coordinates repeatedly
                if (lastMunicipalityCoords && lastMunicipalityCoords.x === x && lastMunicipalityCoords.y === y) return;

                lastMunicipalityCoords = { x, y };

                const url = `https://api.dataforsyningen.dk/kommuner/reverse?x=${encodeURIComponent(x)}&y=${encodeURIComponent(y)}`;
                const resp = await fetch(url);
                const outDiv = document.getElementById('municipalityName');
                if (!resp.ok) {
                    if (outDiv) outDiv.textContent = 'Municipality lookup failed';
                    return;
                }
                const data = await resp.json();
                if (data && data.navn) {
                    const name = data.navn.trim();
                    if (outDiv) outDiv.textContent = `Municipality: ${name}`;

                    // Try to select matching option in the municipality select
                    try {
                        const select = document.getElementById('municipality');
                        if (select) {
                            const candidates = [name];
                            if (name === 'KÃ¸benhavn') candidates.push('Copenhagen');
                            if (name === 'Ã…rhus') candidates.push('Aarhus');
                            const folded = name.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
                            if (!candidates.includes(folded)) candidates.push(folded);
                            const translit = name.replace(/Ã…/g, 'Aa').replace(/Ã¥/g, 'aa')
                                .replace(/Ã†/g, 'Ae').replace(/Ã¦/g, 'ae')
                                .replace(/Ã˜/g, 'O').replace(/Ã¸/g, 'o');
                            if (!candidates.includes(translit)) candidates.push(translit);

                            // Find matching option
                            let matchedValue = null;
                            for (let i = 0; i < select.options.length; i++) {
                                const opt = select.options[i];
                                const optText = opt.text.trim();
                                for (const cand of candidates) {
                                    if (optText.toLowerCase() === cand.toLowerCase()) {
                                        matchedValue = opt.value;
                                        break;
                                    }
                                }
                                if (matchedValue) break;
                            }

                            if (matchedValue) {
                                // Only change value and trigger update if it actually differs
                                if (select.value !== matchedValue) {
                                    // Prevent lookup re-entry while we update the form
                                    skipMunicipalityLookup = true;
                                    select.value = matchedValue;
                                    // Schedule a qstat update asynchronously and then re-enable lookup
                                    setTimeout(() => {
                                        try { updateQuickStatements(); } catch (e) { }
                                        skipMunicipalityLookup = false;
                                    }, 0);
                                }
                            }
                        }
                    } catch (e) { /* ignore selection errors */ }
                } else {
                    if (outDiv) outDiv.textContent = 'Municipality not found';
                }
            } catch (err) {
                try { document.getElementById('municipalityName').textContent = 'Municipality lookup error'; } catch (e) { }
            }
        }

        // Load full OSM element data and populate form fields
        async function loadFromOSM(type) {
            try {
                const idEl = document.getElementById('osm' + capitalize(type));
                if (!idEl) return;
                const id = idEl.value.trim();
                if (!/^\d+$/.test(id)) return;
                // Choose URL: for way/relation we want /full to retrieve nodes
                let url;
                if (type === 'way' || type === 'relation') {
                    url = `https://api.openstreetmap.org/api/0.6/${type}/${id}/full`;
                } else {
                    url = `https://api.openstreetmap.org/api/0.6/${type}/${id}`;
                }
                const resp = await fetch(url);
                if (!resp.ok) return;
                const text = await resp.text();
                const parser = new DOMParser();
                const xml = parser.parseFromString(text, 'application/xml');

                // Get the main element (node/way/relation)
                const mainElem = xml.querySelector(type);
                if (!mainElem) return;

                // Extract tags into a map
                const tags = {};
                mainElem.querySelectorAll('tag').forEach(t => {
                    const k = t.getAttribute('k');
                    const v = t.getAttribute('v');
                    tags[k] = v;
                });

                // Update label from name tag
                if (tags['name']) {
                    document.getElementById('label').value = tags['name'];
                    updateNameSplitSuggestion();
                    // Notify listeners that the label changed programmatically
                    try { document.getElementById('label').dispatchEvent(new Event('change', { bubbles: true })); } catch (e) { }
                }

                // Determine subtype from tags (place/natural)
                const placeToQ = {
                    'hamlet': 'Q5084',
                    'isolated_dwelling': 'Q5084',
                    'village': 'Q532',
                    'town': 'Q3957',
                    'city': 'Q515',
                    'suburb': 'Q188509',
                    'quarter': 'Q2983893',
                    'neighbourhood': 'Q2983893',
                };
                if (tags['place'] && placeToQ[tags['place']]) {
                    document.getElementById('subType').value = placeToQ[tags['place']];
                } else if (tags['landuse'] === 'forest') {
                    document.getElementById('subType').value = 'Q4421';
                } else if (tags['landuse'] === 'farmyard') {
                    document.getElementById('subType').value = 'Q131596';
                } else if (tags['natural'] === 'hill') {
                    document.getElementById('subType').value = 'Q54050';
                } else if (tags['water'] === 'lake') {
                    document.getElementById('subType').value = 'Q23397';
                } else if ("bridge" in tags && tags['bridge'] != 'no') {
                    document.getElementById('subType').value = 'Q12280';
                }
                // Ensure subtype UI updates
                updateSubtypeUI();

                // Coordinates: node lat/lon attribute
                if (type === 'node') {
                    const lat = mainElem.getAttribute('lat');
                    const lon = mainElem.getAttribute('lon');
                    if (lat && lon) document.getElementById('coordinates').value = `${lat},${lon}`;
                } else {
                    // For way/relation, compute centroid from available <node> elements in the returned XML
                    const nodes = xml.querySelectorAll('node');
                    if (nodes.length > 0) {
                        let sumLat = 0, sumLon = 0;
                        let count = 0;
                        nodes.forEach(n => {
                            const lat = parseFloat(n.getAttribute('lat'));
                            const lon = parseFloat(n.getAttribute('lon'));
                            if (isFinite(lat) && isFinite(lon)) {
                                sumLat += lat;
                                sumLon += lon;
                                count++;
                            }
                        });
                        if (count > 0) {
                            const centLat = (sumLat / count).toFixed(6);
                            const centLon = (sumLon / count).toFixed(6);
                            document.getElementById('coordinates').value = `${centLat},${centLon}`;
                        }
                    }
                }

                // Elevation for hills (ele tag)
                if (tags['ele']) {
                    const cleaned = tags['ele'].replace(',', '.');
                    if (isFinite(cleaned)) document.getElementById('elevation').value = cleaned;
                }

                // Update quick statements
                updateQuickStatements();
            } catch (err) {
                // ignore
            }
        }

        // Debounced address fetch when address input is numeric (assume node id)
        let addressFetchTimer = null;
        function scheduleFetchAddress() {
            if (addressFetchTimer) clearTimeout(addressFetchTimer);
            addressFetchTimer = setTimeout(fetchAddressFromNode, 400);
        }

        async function fetchAddressFromNode() {
            try {
                const val = document.getElementById('address').value.trim();
                const linkDiv = document.getElementById('addressNodeLink');
                if (!/^\d+$/.test(val)) {
                    if (linkDiv) { linkDiv.innerHTML = ''; linkDiv.removeAttribute('data-label'); }
                    return;
                }
                const url = `https://api.openstreetmap.org/api/0.6/node/${val}`;
                const resp = await fetch(url);
                if (!resp.ok) {
                    if (linkDiv) { linkDiv.textContent = 'OSM node not found'; linkDiv.removeAttribute('data-label'); }
                    return;
                }
                const text = await resp.text();
                const parser = new DOMParser();
                const xml = parser.parseFromString(text, 'application/xml');
                const node = xml.querySelector('node');
                if (!node) return;
                const tags = {};
                node.querySelectorAll('tag').forEach(t => {
                    tags[t.getAttribute('k')] = t.getAttribute('v');
                });
                // Build parts
                const part1 = (tags['addr:street'] ? tags['addr:street'] : '') + (tags['addr:housenumber'] ? (tags['addr:street'] ? ' ' : '') + tags['addr:housenumber'] : '');
                const part2 = tags['addr:place'] ? tags['addr:place'] : '';
                const part3 = ((tags['addr:postcode'] ? tags['addr:postcode'] : '') + (tags['addr:city'] ? (tags['addr:postcode'] ? ' ' : '') + tags['addr:city'] : '')).trim();
                const parts = [];
                if (part1) parts.push(part1);
                if (part2) parts.push(part2);
                if (part3) parts.push(part3);
                if (parts.length === 0) {
                    if (linkDiv) { linkDiv.textContent = 'No addr:* tags'; linkDiv.removeAttribute('data-label'); }
                    return;
                }
                const label = parts.join(', ');
                if (linkDiv) {
                    linkDiv.innerHTML = `<a href="#" onclick="document.getElementById('address').value=\'${escapeHtml(label).replace(/'/g, "\\'")}\'; updateQuickStatements(); return false;">Load address: ${escapeHtml(label)}</a>`;
                    linkDiv.setAttribute('data-label', label);
                }
            } catch (err) {
                // ignore
            }
        }

        function populateSelectOptions(selectElement, options) {
            for (let value in options) {
                let option = document.createElement('option');
                option.value = value;
                option.text = options[value];
                selectElement.add(option);
            }
        }

        function copyToClipboard() {
            let quickStatements = document.getElementById('quickStatements');
            quickStatements.select();
            quickStatements.setSelectionRange(0, 99999); // For mobile devices
            document.execCommand('copy');

            let notification = document.getElementById('copyNotification');
            notification.style.display = 'block';
            setTimeout(() => {
                notification.style.display = 'none';
            }, 2000);
        }

        function updateNameSplitSuggestion() {
            const label = document.getElementById('label').value.trim();
            const container = document.getElementById('nameSplitSuggestion');
            if (!label) {
                container.innerHTML = '';
                return;
            }
            const parts = label.split(/\s+/);
            if (parts.length < 2) {
                container.innerHTML = '';
                return;
            }
            let html = '<b>Split full name:</b> ';
            for (let i = 0; i < parts.length; i++) {
                if (i > 0) {
                    let first = parts.slice(0, i).join(' ');
                    let sur = parts.slice(i).join(' ');
                    html += `<a href="#" onclick="setNameSplit('${first.replace(/'/g, "\\'")}', '${sur.replace(/'/g, "\\'")}'); return false;" style="text-decoration:none; font-size:18px; vertical-align:middle;" title='Split here'>âœ‚</a> `;
                }
                html += parts[i];
                if (i < parts.length - 1) html += ' ';
            }
            container.innerHTML = html;
        }

        function setNameSplit(first, sur) {
            document.getElementById('firstName').value = first;
            document.getElementById('surname').value = sur;
            lookupNameParts('firstName');
            lookupNameParts('surname');
        }

        // Wait for DOMContentLoaded before adding event listener
        document.addEventListener('DOMContentLoaded', function () {
            var labelInput = document.getElementById('label');
            if (labelInput) {
                labelInput.addEventListener('blur', updateNameSplitSuggestion);
                labelInput.addEventListener('blur', lookupLabelExact);
                // Also run exact label lookup when the field's value is changed programmatically
                labelInput.addEventListener('change', lookupLabelExact);
            }
            // Update subtype suggestion when description changes
            try {
                var descEl = document.getElementById('description');
                if (descEl) descEl.addEventListener('input', updateSubTypeSuggestion);
            } catch (e) { }
            // Intercept accesskey + s and call applySubTypeSuggestion directly
            try {
                document.addEventListener('keydown', function (e) {
                    // Typical accesskey combos: Alt+S (Windows), Meta+Alt+S or Ctrl+Opt on Mac - accept Alt or Meta as modifier
                    if ((e.key === 's' || e.key === 'S') && (e.altKey || e.metaKey)) {
                        var suggestionEl = document.getElementById('subTypeSuggestion');
                        if (suggestionEl && suggestionEl.dataset && suggestionEl.dataset.q) {
                            e.preventDefault();
                            e.stopPropagation();
                            try { applySubTypeSuggestion(suggestionEl.dataset.q); } catch (err) { }
                        }
                    }
                }, false);
            } catch (e) { }
            // Bind Enter to loadFromOSM for OSM ID inputs so Return triggers loading
            ['osmNode', 'osmWay', 'osmRelation'].forEach(function (id) {
                try {
                    var el = document.getElementById(id);
                    if (!el) return;
                    el.addEventListener('keydown', function (e) {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            var type = (id === 'osmNode') ? 'node' : (id === 'osmWay') ? 'way' : 'relation';
                            try { loadFromOSM(type); } catch (err) { }
                            try {
                                var desc = document.getElementById('description');
                                if (desc) desc.focus();
                            } catch (err) { }
                        }
                    });
                } catch (e) { }
            });

            // Accept Enter in address: fetch suggestion and apply it as if the link was clicked
            var addrEl = document.getElementById('address');
            if (addrEl) {
                addrEl.addEventListener('keydown', function (e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        // Ensure latest suggestion is fetched
                        fetchAddressFromNode().then(function () {
                            var linkDiv = document.getElementById('addressNodeLink');
                            if (linkDiv && linkDiv.hasAttribute('data-label')) {
                                document.getElementById('address').value = linkDiv.getAttribute('data-label');
                                updateQuickStatements();
                            }
                        }).catch(function () { /* ignore */ });
                    }
                });
            }

            updateNameSplitSuggestion();
        });
    </script>
    <style>
        /* Styled radio buttons that look like regular buttons for the "Type" selector */
        .type-buttons {
            display: inline-block;
            vertical-align: middle;
        }

        .type-buttons .btn {
            display: inline-block;
            border: 1px solid #888;
            background: #f2f2f2;
            color: #000;
            padding: 6px 10px;
            margin-right: 6px;
            border-radius: 4px;
            cursor: pointer;
            user-select: none;
            font-size: 14px;
        }

        .type-buttons .btn.selected {
            background: #0078d7;
            color: #fff;
            border-color: #005a9e;
        }

        .type-buttons .btn:focus {
            outline: 2px solid #cce5ff;
        }
        /* Common small informational text used under inputs */
        .info-text {
            margin-top: 6px;
            color: #333;
            font-size: 90%;
        }
        /* Slightly tighter inline info (used for OSM element name links, address helper) */
        .inline-info {
            margin-top: 4px;
            color: #333;
            font-size: 90%;
        }
        /* Notification used when copying quick statements */
        .copy-notification {
            display: none;
            color: green;
        }
        /* Hidden form sections default - toggled via JS */
        #humanFields, #locationFields {
            display: none;
        }
        .subtype-suggestion {
            display: inline-block;
            margin-left: 8px;
            font-size: 90%;
            color: #0078d7;
            text-decoration: none;
            cursor: pointer;
        }
        .hidden { display: none; }

        #address {
            background-color: white;
            border: 1px solid #888;
        }

        #address:invalid {
            background-color: lightpink;
            border: 1px solid #888;
        }
    </style>
</head>

<body>
    <h1>Wikidata Auto</h1>
    <form>
        <label for="label">Danish Label:</label>
        <input type="text" id="label" name="label" oninput="updateQuickStatements()" size="50"><br>
        <div id="labelLookup" class="info-text"></div><br>

        <label for="description">Danish Description:</label>
        <input type="text" id="description" name="description" oninput="updateQuickStatements()" size="50"><br><br>

        <label for="alias">Danish Alias:</label>
        <input type="text" id="alias" name="alias" oninput="updateQuickStatements()" size="50"><br><br>

        <label for="type">Type:</label>
        <div class="type-buttons" role="radiogroup" aria-label="Type">
            <input type="radio" id="type_Location" name="typeRadio" value="Location" checked style="display:none">
            <label class="btn selected" for="type_Location" onclick="setType('Location')"
                onkeydown="if(event.key==='Enter'||event.key===' ') { setType('Location'); event.preventDefault(); }">Location</label>

            <input type="radio" id="type_Human" name="typeRadio" value="Human" style="display:none">
            <label class="btn" for="type_Human" onclick="setType('Human')"
                onkeydown="if(event.key==='Enter'||event.key===' ') { setType('Human'); event.preventDefault(); }">Human</label>

            <input type="radio" id="type_Name" name="typeRadio" value="Name" style="display:none">
            <label class="btn" for="type_Name" onclick="setType('Name')"
                onkeydown="if(event.key==='Enter'||event.key===' ') { setType('Name'); event.preventDefault(); }">Name</label>
        </div>
        <!-- Hidden input kept for backwards compatibility with existing JS that reads #type.value -->
        <input type="hidden" id="type" name="type" value="Location">
        <br><br>

        <label for="subType">Subtype:</label>
        <select id="subType" name="subType" onchange="updateSubtypeUI(); updateQuickStatements()">
            <!-- Options will be populated by JavaScript -->
        </select>
        <a id="subTypeSuggestion" class="subtype-suggestion hidden" href="#" aria-hidden="true" accesskey="s"></a>
        <span id="subTypeWarning" style="color:#a00; margin-left:8px; font-weight:600;"
            title="City should not have an address"></span>
        <br><br>


        <div id="locationFields">
            <label for="country">Country (Denmark):</label>
            <input type="checkbox" id="country" name="country" onchange="updateQuickStatements()" checked><br><br>

            <label for="municipality">Municipality:</label>
            <select id="municipality" name="municipality" onchange="updateQuickStatements()">
                <!-- Options will be populated by JavaScript -->
            </select><br><br>

            <label for="coordinates">Coordinates (P625):</label>
            <input type="text" id="coordinates" name="coordinates" oninput="updateQuickStatements()">
            <!-- <div id="osmCoordinateLink" style="margin-top:5px;"></div><br><br> -->
            <div id="osmCoordinateLink"></div>
            <div id="municipalityName" class="info-text"></div><br>

            <div id="elevationField" style="margin-bottom:8px;">
                <label for="elevation">Elevation (meters, P2044):</label>
                <input type="text" id="elevation" name="elevation" oninput="updateQuickStatements()"
                    placeholder="e.g. 55.3">
            </div><br>

            <label for="address">Address (P6375):</label>
            <input type="text" id="address" name="address" pattern="^[^\d].*"
                oninput="updateQuickStatements(); scheduleFetchAddress(); updateSubtypeUI()" size="50">
            <div id="addressNodeLink" class="inline-info"></div><br><br>

            <label for="osmNode">OpenStreetMap Node ID (P11693):</label>
            <input type="text" id="osmNode" name="osmNode" oninput="updateQuickStatements(); scheduleFetchOSM('node')">
            <div id="osmNodeName" class="inline-info"></div><br>

            <label for="osmWay">OpenStreetMap Way ID (P10689):</label>
            <input type="text" id="osmWay" name="osmWay" oninput="updateQuickStatements(); scheduleFetchOSM('way')">
            <div id="osmWayName" class="inline-info"></div><br>

            <label for="osmRelation">OpenStreetMap Relation ID (P402):</label>
            <input type="text" id="osmRelation" name="osmRelation"
                oninput="updateQuickStatements(); scheduleFetchOSM('relation')">
            <div id="osmRelationName" class="inline-info"></div><br>
        </div>

        <div id="humanFields">
            <label for="citizenship">Citizenship (Kingdom of Denmark):</label>
            <input type="checkbox" id="citizenship" name="citizenship" onchange="updateQuickStatements()"
                checked><br><br>

            <label for="birthDate">Birth Date:</label>
            <input type="text" id="birthDate" name="birthDate" oninput="updateQuickStatements()"><br><br>

            <label for="deathDate">Death Date:</label>
            <input type="text" id="deathDate" name="deathDate" oninput="updateQuickStatements()"><br><br>

            <label for="occupation">Occupation:</label>
            <select id="occupation" name="occupation" onchange="updateQuickStatements()">
                <!-- Options will be populated by JavaScript -->
            </select><br><br>

            <label for="positionHeld">Position held:</label>
            <select id="positionHeld" name="positionHeld" onchange="updateQuickStatements()">
                <!-- Options will be populated by JavaScript -->
            </select><br>
            <div id="positionHeldDates" style="display:none;">
                <label for="positionStart">Start date:</label>
                <input type="text" id="positionStart" name="positionStart" oninput="updateQuickStatements()"><br>
                <label for="positionEnd">End date:</label>
                <input type="text" id="positionEnd" name="positionEnd" oninput="updateQuickStatements()"><br>
            </div><br>

            <label for="source">Source (Wikidata item or URL):</label>
            <input type="text" id="source" name="source" oninput="updateQuickStatements()"><br><br>

            <div id="nameSplitSuggestion" style="margin-bottom: 10px;"></div>
            <label for="firstName">First name:</label>
            <input type="text" id="firstName" name="firstName" oninput="lookupNameParts('firstName')"><br>
            <div id="firstNameResults"></div><br>

            <label for="surname">Surname:</label>
            <input type="text" id="surname" name="surname" oninput="lookupNameParts('surname')"><br>
            <div id="surnameResults"></div><br>
        </div>

        <label for="quickStatements">QuickStatements:</label><br>
        <textarea id="quickStatements" name="quickStatements" rows="10" cols="50" readonly></textarea><br>
        <a href="#" onclick="copyToClipboard()">Copy to Clipboard</a>
        <div id="copyNotification" class="copy-notification">Copied to clipboard!</div><br>
        <a id="quickStatementsLink" href="#" target="_blank" accesskey="a">Open in QuickStatements</a>
    </form>

    <script>
        // Initialize the form with default values
        updateSubTypeOptions();
        populateSelectOptions(document.getElementById('occupation'), occupations);
        populateSelectOptions(document.getElementById('positionHeld'), positionsHeld);
        populateSelectOptions(document.getElementById('municipality'), municipalities);
    </script>
</body>

</html>