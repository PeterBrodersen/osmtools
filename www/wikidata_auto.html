<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wikidata Auto</title>
    <script>
        const locations = {
            "Q515": "City",
            "Q2983893": "City quarter",
            "Q188509": "Suburb",
            "Q3957": "Town",
            "Q532": "Village",
            "Q5084": "Hamlet",
            "Q486972": "Human Settlement",
            "Q12336407": "Holiday home area",
            "Q54050": "Hill",
            "Q131596": "Farm",
            "Q12280": "Bridge",
            "Q1681353": "Bog",
            "Q188869": "Field",
            "Q7777019": "Meadow",
            "Q41176": "Building",
            "Q3947": "House",
            "Q879050": "Manor house",
            "Q1371789": "Summer house",
            "Q4421": "Forest",
            "Q23397": "Lake",
            "Q22698": "Park",
            "Q16970": "Church",
            "Q2221906": "Geographic location",
        };

        const occupations = {
            "": "Select Occupation",
            "Q82955": "Politician",
            "Q42855995": "Fabricator",
            "Q331432": "Fisher",
            "Q1897112": "Skipper",
            "Q78597495": "Strandfoged",
            "Q37226": "Teacher",
            "Q61743173": "Vognmand",
            "Q39631": "Doctor",
            "Q131512": "Farmer",
        };

        const municipalities = {
            "": "Select Municipality",
            "Q504125": "Copenhagen",
            "Q240262": "Aarhus",
            "Q21146": "Odense",
            "Q300856": "Aalborg",
            "Q7715809": "Thisted",
            "Q506109": "Holstebro",
            "Q510810": "Roskilde",
            "Q30013": "Nyborg",
            "Q502962": "Viborg",
            "Q512457": "Randers",
            "Q503108": "Skive",
            "Q645747": "Esbjerg",
            "Q21142": "Varde",
            "Q506716": "NÃ¦stved",
            "Q505000": "Faxe",
            "Q503116": "Ringsted",
            "Q28150": "Vejle",
            "Q183572": "Vordingborg",
            "Q493833": "Albertslund",
            "Q499400": "HÃ¸je-Taastrup",
            "Q204976": "Kalundborg",
            "Q503159": "HolbÃ¦k",
            "Q512581": "Syddjurs",
            "Q505156": "Norddjurs",
            "Q282496": "TÃ¥rnby",
            "Q500076": "Gentofte",
            "Q21182": "Svendborg",
            "Q510997": "Guldborgsund",
            "Q670153": "Lolland",
            "Q27967": "Assens",
            "Q221394": "HillerÃ¸d",
            "Q493826": "Lyngby-TaarbÃ¦k",
            "Q612488": "Kerteminde",
            "Q503227": "Struer",
            "Q1425064": "Odsherred",
            "Q29927": "Slagelse",
            "Q506877": "Herning",
            "Q502770": "MorsÃ¸",
            "Q21108": "SÃ¸nderborg",
            "Q503045": "Fredensborg",
            "Q511949": "Rudersdal",
            "Q505130": "HalsnÃ¦s",
            "Q512540": "HÃ¸rsholm",
            "Q504977": "Greve",
            "Q21140": "Middelfart",
            "Q27875": "Billund",
            "Q494827": "Gribskov",
            "Q257223": "Ballerup",
            "Q164490": "Herlev",
            "Q502168": "Frederikshavn",
            "Q2598329": "Bornholm",
            "Q514777": "RingkÃ¸bing-Skjern",
            "Q505369": "Lejre",
            "Q512595": "Ikast-Brande",
            "Q3162907": "TÃ¸nder",
            "Q515986": "Hedensted",
            "Q21145": "Fredericia",
            "Q500058": "Odder",
            "Q511214": "HjÃ¸rring",
            "Q511376": "BrÃ¸nderslev",
            "Q21101": "Kolding",
            "Q21151": "SorÃ¸",
            "Q484018": "Gladsaxe",
            "Q505113": "Egedal",
            "Q21150": "Vejen",
            "Q21152": "Aabenraa",
            "Q21143": "Haderslev",
            "Q512562": "Hvidovre",
            "Q511975": "Vesthimmerlands",
            "Q503222": "Jammerbugt",
            "Q2488464": "Frederiksberg",
            "Q512064": "Horsens",
            "Q27976": "Faaborg-Midtfyn",
            "Q20770": "Nordfyns",
            // Add more municipalities as needed
        };

        const positionsHeld = {
            "": "Select Position",
            "Q30185": "Mayor",
            "Q708492": "Council member",
            "Q12336313": "Sognefoged",
            "Q5004082": "Byfoged",
        };

        function formatDate(date) {
            if (!date) return '';
            let precision = 9; // Default precision is year

            // Allow spaces and multiple delimiters between day, month, year
            // Match: 1-2 digits, delimiter(s), 1-2 digits, delimiter(s), 4 digits
            let dmyMatch = date.match(/^(\d{1,2})[\s\-\/\.]+(\d{1,2})[\s\-\/\.]+(\d{4})$/);
            if (dmyMatch) {
                let day = dmyMatch[1].padStart(2, '0');
                let month = dmyMatch[2].padStart(2, '0');
                let year = dmyMatch[3];
                precision = 11;
                date = `+${year}-${month}-${day}T00:00:00Z`;
            } else if (date.match(/^\d{4}$/)) {
                precision = 9;
                date = `+${date}-00-00T00:00:00Z`;
            } else if (date.match(/^\d{4}-\d{2}$/)) {
                precision = 10;
                date = `+${date}-00T00:00:00Z`;
            } else if (date.match(/^\d{4}-\d{2}-\d{2}$/)) {
                precision = 11;
                date = `+${date}T00:00:00Z`;
            }
            return `${date}/${precision}`;
        }

        // Parse a coordinates string into an object {lat, lng} or return false if invalid.
        function parseCoordinates(str) {
            if (!str || typeof str !== 'string') return false;
            str = str.trim();
            // Count commas
            const commaCount = (str.match(/,/g) || []).length;
            // Case A: three commas used as decimal separators, e.g. "12,34, 56,78"
            if (commaCount === 3) {
                const parts = str.split(',');
                if (parts.length === 4) {
                    const lat = parts[0].trim() + '.' + parts[1].trim();
                    const lng = parts[2].trim() + '.' + parts[3].trim();
                    if (!isFinite(lat) || !isFinite(lng)) return false;
                    return { lat: lat, lng: lng };
                }
                return false;
            }
            // Case B: standard "lat,lng" (one comma)
            if (commaCount === 1) {
                const parts = str.split(',');
                if (parts.length === 2) {
                    const lat = parts[0].trim();
                    const lng = parts[1].trim();
                    if (!lat || !lng || !isFinite(lat) || !isFinite(lng)) return false;
                    return { lat: lat, lng: lng };
                }
                return false;
            }
            // Anything else is invalid
            return false;
        }

        // Format a {lat, lng} object into QuickStatements string "@lat/lng" or return false.
        function formatCoordinatesQS(coordObj) {
            if (!coordObj || typeof coordObj !== 'object') return false;
            if (!('lat' in coordObj) || !('lng' in coordObj)) return false;
            const lat = coordObj.lat;
            const lng = coordObj.lng;
            if (!isFinite(lat) || !isFinite(lng)) return false;
            return `@${lat}/${lng}`;
        }

        function getSourceStatement(source) {
            if (!source) return '';
            source = source.trim();
            if (source.match(/^Q\d+$/)) { // Wikidata item ID
                return `|S248|${source}`;
            } else if (source.match(/^geni\s+(\d+)$/i)) { // Geni ID
                const geniId = source.match(/^geni\s+(\d+)$/i)[1];
                return `|S2600|"${geniId}"`;
            } else if (source.match(/^gravsted\s+(.+)$/i)) { // Gravsted ID
                const gravstedId = source.match(/^gravsted\s+(.+)$/i)[1];
                return `|P4359|"${gravstedId}"`;
            } else { // URL or other source
                return `|S854|"${source}"`;
            }
        }

        let firstNameItems = [];
        let surnameItems = [];

        let lookupTimers = { firstName: null, surname: null };
        let lookupTokens = { firstName: '', surname: '' };

        function lookupNameParts(type) {
            let input = document.getElementById(type).value.trim();
            let token = input.toLowerCase();
            lookupTokens[type] = token;
            if (lookupTimers[type]) clearTimeout(lookupTimers[type]);
            lookupTimers[type] = setTimeout(() => {
                doLookupNameParts(type, input, token);
            }, 300);
        }

        async function doLookupNameParts(type, input, token) {
            let words = input.split(/\s+/).filter(Boolean);
            let resultsDiv = document.getElementById(type + 'Results');
            resultsDiv.innerHTML = '';
            if (words.length === 0) {
                if (type === 'firstName') firstNameItems = [];
                if (type === 'surname') surnameItems = [];
                updateQuickStatements();
                return;
            }
            let items = [];
            for (let i = 0; i < words.length; i++) {
                let word = words[i];
                let sparql = '';
                if (type === 'firstName') {
                    sparql = `SELECT ?item ?itemLabel WHERE {
                        ?item rdfs:label ?lbl.
                        VALUES ?lbl { "${word}"@da "${word}"@en "${word}"@mul }
                        ?item rdfs:label ?lbl.
                        ?item wdt:P31 ?type.
                        VALUES ?type { wd:Q202444 wd:Q12308941 wd:Q11879590 wd:Q3409032 }
                        SERVICE wikibase:label { bd:serviceParam wikibase:language "da,en,mul". }
                    } LIMIT 1`;
                } else {
                    sparql = `SELECT ?item ?itemLabel WHERE {
                        VALUES ?lbl { "${word}"@da "${word}"@en "${word}"@mul }
                        ?item rdfs:label ?lbl.
                        ?item wdt:P31 wd:Q101352.
                        SERVICE wikibase:label { bd:serviceParam wikibase:language "da,en,mul". }
                    } LIMIT 1`;
                }
                let url = 'https://query.wikidata.org/sparql?format=json&query=' + encodeURIComponent(sparql);
                let response = await fetch(url);
                // Check if the input has changed since the request was sent
                if (lookupTokens[type] !== token) return;
                let data = await response.json();
                if (data.results.bindings.length > 0) {
                    let item = data.results.bindings[0].item.value;
                    let itemId = item.split('/').pop();
                    let label = data.results.bindings[0].itemLabel.value;
                    items.push({ id: itemId, label });
                } else {
                    items.push({ id: null, label: word });
                }
            }
            // Check again before updating results
            if (lookupTokens[type] !== token) return;
            let html = words.map((w, i) => {
                let item = items[i];
                if (item.id) {
                    return `<a href="https://www.wikidata.org/wiki/${item.id}" target="_blank">${item.label}</a>`;
                } else {
                    return `<span>${item.label}</span>`;
                }
            }).join(' ');
            resultsDiv.innerHTML = html;
            if (type === 'firstName') firstNameItems = items;
            if (type === 'surname') surnameItems = items;
            if (document.getElementById('type').value === 'Human') {
                updateQuickStatements();
            }
        }

        function updateQuickStatements() {
            let type = document.getElementById('type').value;
            let subType = document.getElementById('subType').value;
            let birthDate = formatDate(document.getElementById('birthDate').value);
            let deathDate = formatDate(document.getElementById('deathDate').value);
            let citizenship = document.getElementById('citizenship').checked ? 'Q756617' : '';
            let source = getSourceStatement(document.getElementById('source').value);
            let label = document.getElementById('label').value;
            let description = document.getElementById('description').value;
            let alias = document.getElementById('alias').value;
            let occupation = document.getElementById('occupation').value;
            let positionHeld = document.getElementById('positionHeld').value;
            let positionStart = document.getElementById('positionStart').value;
            let positionEnd = document.getElementById('positionEnd').value;
            let country = document.getElementById('country').checked ? 'Q35' : '';
            let municipality = document.getElementById('municipality').value;
            // Parse coordinates and format for QuickStatements
            let coordObj = parseCoordinates(document.getElementById('coordinates').value);
            let coordinates = coordObj ? formatCoordinatesQS(coordObj) : '';
            let osmNode = document.getElementById('osmNode').value;
            let osmWay = document.getElementById('osmWay').value;
            let osmRelation = document.getElementById('osmRelation').value;
            let address = document.getElementById('address').value;

            // Show/hide positionHeldDates
            if (type === 'Human' && positionHeld) {
                document.getElementById('positionHeldDates').style.display = 'block';
            } else {
                document.getElementById('positionHeldDates').style.display = 'none';
            }

            let quickStatements = 'CREATE\n';

            if (type === 'Human') {
                quickStatements += 'LAST|P31|Q5\n';
                if (subType === 'Man') {
                    quickStatements += 'LAST|P21|Q6581097\n';
                } else if (subType === 'Woman') {
                    quickStatements += 'LAST|P21|Q6581072\n';
                }
                if (birthDate) {
                    quickStatements += `LAST|P569|${birthDate}${source}\n`;
                }
                if (deathDate) {
                    quickStatements += `LAST|P570|${deathDate}${source}\n`;
                }
                if (citizenship) {
                    quickStatements += `LAST|P27|${citizenship}\n`;
                }
                if (occupation) {
                    quickStatements += `LAST|P106|${occupation}${source}\n`;
                }
                if (positionHeld) {
                    quickStatements += `LAST|P39|${positionHeld}`;
                    let start = formatDate(positionStart);
                    let end = formatDate(positionEnd);
                    if (start && start !== '+-00-00T00:00:00Z/9') quickStatements += `|P580|${start}`;
                    if (end && end !== '+-00-00T00:00:00Z/9') quickStatements += `|P582|${end}`;
                    quickStatements += `${source}\n`;
                }
                // Add given names (P735) and family names (P734) from lookup ONLY for Human
                if (firstNameItems.length > 0) {
                    firstNameItems.forEach((item, idx) => {
                        if (item.id) {
                            if (firstNameItems.length > 1) {
                                quickStatements += `LAST|P735|${item.id}|P1545|"${idx + 1}"\n`;
                            } else {
                                quickStatements += `LAST|P735|${item.id}\n`;
                            }
                        }
                    });
                }
                if (surnameItems.length > 0) {
                    surnameItems.forEach((item, idx) => {
                        if (item.id) {
                            if (surnameItems.length > 1) {
                                quickStatements += `LAST|P734|${item.id}|P1545|"${idx + 1}"\n`;
                            } else {
                                quickStatements += `LAST|P734|${item.id}\n`;
                            }
                        }
                    });
                }
            } else if (type === 'Location') {
                if (subType) {
                    quickStatements += `LAST|P31|${subType}\n`;
                }
                if (country) {
                    quickStatements += `LAST|P17|${country}\n`;
                }
                if (municipality) {
                    quickStatements += `LAST|P131|${municipality}\n`;
                }
                if (address) {
                    quickStatements += `LAST|P6375|da:"${address}"\n`;
                }
                // Elevation for Hill (P2044) in meters (unit Q11573)
                try {
                    let elevationVal = document.getElementById('elevation') ? document.getElementById('elevation').value.trim() : '';
                    console.log('Elevation value:', elevationVal);
                    if (subType === 'Q54050' && elevationVal) {
                        // QuickStatements quantity with unit: +<value>/9 and then unit as S<item>
                        // Using the user's requested pattern: LAST|P2044|+<value>/9|S11573
                        let cleaned = elevationVal.replace(',', '.');
                        if (isFinite(cleaned)) {
                            quickStatements += `LAST|P2044|${cleaned}U11573\n`;
                        }
                    }
                } catch (e) { }
                if (coordinates) {
                    quickStatements += `LAST|P625|${coordinates}\n`;
                }
                if (osmNode) {
                    quickStatements += `LAST|P11693|"${osmNode}"\n`;
                }
                if (osmWay) {
                    quickStatements += `LAST|P10689|"${osmWay}"\n`;
                }
                if (osmRelation) {
                    quickStatements += `LAST|P402|"${osmRelation}"\n`;
                }
            } else if (type === 'Name') {
                if (subType === 'Surname') {
                    quickStatements += 'LAST|P31|Q101352\n';
                } else if (subType === 'First name') {
                    quickStatements += 'LAST|P31|Q202444\n';
                } else if (subType === 'First name (male)') {
                    quickStatements += 'LAST|P31|Q12308941\n';
                } else if (subType === 'First name (female)') {
                    quickStatements += 'LAST|P31|Q11879590\n';
                }
                quickStatements += 'LAST|P282|Q8229\n';
                if (label) {
                    quickStatements += `LAST|P1705|da:"${label}"\n`;
                }
            }

            if (label) {
                quickStatements += `LAST|Lda|"${label}"\n`;
            }
            if (description) {
                quickStatements += `LAST|Dda|"${description}"\n`;
            }
            if (alias) {
                alias.split('|').forEach(a => {
                    if (a.trim()) {
                        quickStatements += `LAST|Ada|"${a.trim()}"\n`;
                    }
                });
            }

            document.getElementById('quickStatements').value = quickStatements;
            updateQuickStatementsLink(quickStatements);

            // Show OSM link if coordinates are valid
            var osmLinkDiv = document.getElementById('osmCoordinateLink');
            if (osmLinkDiv) {
                if (coordObj) {
                    var lat = coordObj.lat;
                    var lng = coordObj.lng;
                    var url = 'https://www.openstreetmap.org/search?query=' + encodeURIComponent(lat + ',' + lng) + '#map=16/' + lat + '/' + lng;
                    osmLinkDiv.innerHTML = `<a href="${url}" target="_blank">View on OpenStreetMap</a>`;
                } else {
                    osmLinkDiv.innerHTML = '';
                }
            }
        }

        function updateQuickStatementsLink(quickStatements) {
            let encodedStatements = encodeURIComponent(quickStatements).replace(/%0A/g, '%7C%7C');
            let quickStatementsLink = `https://quickstatements.toolforge.org/#/v1=${encodedStatements}`;
            document.getElementById('quickStatementsLink').href = quickStatementsLink;
        }

        function updateSubTypeOptions() {
            let type = document.getElementById('type').value;
            let subType = document.getElementById('subType');
            subType.innerHTML = '';

            if (type === 'Human') {
                subType.innerHTML += '<option value="Man">Man</option>';
                subType.innerHTML += '<option value="Woman">Woman</option>';
                document.getElementById('humanFields').style.display = 'block';
                document.getElementById('cityFields').style.display = 'none';
            } else if (type === 'Location') {
                for (let key in locations) {
                    subType.innerHTML += `<option value="${key}">${locations[key]}</option>`;
                }
                document.getElementById('humanFields').style.display = 'none';
                document.getElementById('cityFields').style.display = 'block';
                document.getElementById('elevationField').style.display = (subType.value === 'Q54050') ? 'block' : 'none';
            } else if (type === 'Name') {
                subType.innerHTML += '<option value="Surname">Surname</option>';
                subType.innerHTML += '<option value="First name">First name</option>';
                subType.innerHTML += '<option value="First name (male)">First name (male)</option>';
                subType.innerHTML += '<option value="First name (female)">First name (female)</option>';
                document.getElementById('humanFields').style.display = 'none';
                document.getElementById('cityFields').style.display = 'none';
            }
            updateQuickStatements();
        }

        // Toggle UI elements that depend on the selected subtype
        function updateSubtypeUI() {
            try {
                var subTypeEl = document.getElementById('subType');
                var elevationField = document.getElementById('elevationField');
                if (subTypeEl && elevationField) {
                    elevationField.style.display = (subTypeEl.value === 'Q54050') ? 'block' : 'none';
                }
            } catch (e) { }
        }

        // Debounced fetch for OSM element name tag
        const osmFetchTimers = { node: null, way: null, relation: null };

        function scheduleFetchOSM(type) {
            try {
                if (osmFetchTimers[type]) clearTimeout(osmFetchTimers[type]);
                osmFetchTimers[type] = setTimeout(() => fetchOSMElementName(type), 300);
            } catch (e) { }
        }

        async function fetchOSMElementName(type) {
            try {
                const id = document.getElementById('osm' + capitalize(type)).value.trim();
                const resultDiv = document.getElementById('osm' + capitalize(type) + 'Name');
                if (!id) {
                    if (resultDiv) resultDiv.textContent = '';
                    return;
                }
                // Basic validation: id should be digits
                if (!/^\d+$/.test(id)) {
                    if (resultDiv) resultDiv.textContent = 'Invalid ID';
                    return;
                }
                const url = `https://api.openstreetmap.org/api/0.6/${type}/${id}`;
                const resp = await fetch(url);
                if (!resp.ok) {
                    if (resultDiv) resultDiv.textContent = `OSM ${type} not found`;
                    return;
                }
                const text = await resp.text();
                // parse minimal XML to find tag k="name"
                const parser = new DOMParser();
                const xml = parser.parseFromString(text, 'application/xml');
                const elem = xml.querySelector(type);
                if (!elem) {
                    if (resultDiv) resultDiv.textContent = '';
                    return;
                }
                const nameTag = elem.querySelector('tag[k="name"]');
                if (nameTag) {
                    const name = nameTag.getAttribute('v');
                    if (resultDiv) {
                        // Link the name to the OpenStreetMap element page and keep the load-from-OSM emoji button
                        const osmUrl = encodeURI(`https://www.openstreetmap.org/${type}/${id}`);
                        resultDiv.innerHTML = `OSM name: <a href="${osmUrl}" target="_blank">${escapeHtml(name)}</a> <a href="#" onclick="loadFromOSM('${type}'); return false;" title="Load from OSM data">ðŸ“¥</a>`;
                    }
                } else {
                    if (resultDiv) {
                        const osmUrl = encodeURI(`https://www.openstreetmap.org/${type}/${id}`);
                        resultDiv.innerHTML = `<a href="${osmUrl}" target="_blank">OSM ${type} ${escapeHtml(id)} (no name tag)</a>`;
                    }
                }
            } catch (err) {
                // swallow network errors silently
            }
        }

        function capitalize(s) { return s.charAt(0).toUpperCase() + s.slice(1); }

        function escapeHtml(str) {
            return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
        }

        // Load full OSM element data and populate form fields
        async function loadFromOSM(type) {
            try {
                const idEl = document.getElementById('osm' + capitalize(type));
                if (!idEl) return;
                const id = idEl.value.trim();
                if (!/^\d+$/.test(id)) return;
                // Choose URL: for way/relation we want /full to retrieve nodes
                let url;
                if (type === 'way' || type === 'relation') {
                    url = `https://api.openstreetmap.org/api/0.6/${type}/${id}/full`;
                } else {
                    url = `https://api.openstreetmap.org/api/0.6/${type}/${id}`;
                }
                const resp = await fetch(url);
                if (!resp.ok) return;
                const text = await resp.text();
                const parser = new DOMParser();
                const xml = parser.parseFromString(text, 'application/xml');

                // Get the main element (node/way/relation)
                const mainElem = xml.querySelector(type);
                if (!mainElem) return;

                // Extract tags into a map
                const tags = {};
                mainElem.querySelectorAll('tag').forEach(t => {
                    const k = t.getAttribute('k');
                    const v = t.getAttribute('v');
                    tags[k] = v;
                });

                // Update label from name tag
                if (tags['name']) {
                    document.getElementById('label').value = tags['name'];
                    updateNameSplitSuggestion();
                }

                // Determine subtype from tags (place/natural)
                const placeToQ = {
                    'hamlet': 'Q5084',
                    'village': 'Q532',
                    'town': 'Q3957',
                    'city': 'Q515',
                    'suburb': 'Q188509',
                    'quarter': 'Q2983893',
                    'neighbourhood': 'Q2983893',
                };
                if (tags['place'] && placeToQ[tags['place']]) {
                    document.getElementById('subType').value = placeToQ[tags['place']];
                } else if (tags['natural'] === 'hill') {
                    document.getElementById('subType').value = 'Q54050';
                }
                // Ensure subtype UI updates
                updateSubtypeUI();

                // Coordinates: node lat/lon attribute
                if (type === 'node') {
                    const lat = mainElem.getAttribute('lat');
                    const lon = mainElem.getAttribute('lon');
                    if (lat && lon) document.getElementById('coordinates').value = `${lat},${lon}`;
                } else {
                    // For way/relation, compute centroid from available <node> elements in the returned XML
                    const nodes = xml.querySelectorAll('node');
                    if (nodes.length > 0) {
                        let sumLat = 0, sumLon = 0;
                        let count = 0;
                        nodes.forEach(n => {
                            const lat = parseFloat(n.getAttribute('lat'));
                            const lon = parseFloat(n.getAttribute('lon'));
                            if (isFinite(lat) && isFinite(lon)) {
                                sumLat += lat;
                                sumLon += lon;
                                count++;
                            }
                        });
                        if (count > 0) {
                            const centLat = (sumLat / count).toFixed(6);
                            const centLon = (sumLon / count).toFixed(6);
                            document.getElementById('coordinates').value = `${centLat},${centLon}`;
                        }
                    }
                }

                // Elevation for hills (ele tag)
                if (tags['ele']) {
                    const cleaned = tags['ele'].replace(',', '.');
                    if (isFinite(cleaned)) document.getElementById('elevation').value = cleaned;
                }

                // Update quick statements
                updateQuickStatements();
            } catch (err) {
                // ignore
            }
        }

        // Debounced address fetch when address input is numeric (assume node id)
        let addressFetchTimer = null;
        function scheduleFetchAddress() {
            if (addressFetchTimer) clearTimeout(addressFetchTimer);
            addressFetchTimer = setTimeout(fetchAddressFromNode, 400);
        }

        async function fetchAddressFromNode() {
            try {
                const val = document.getElementById('address').value.trim();
                const linkDiv = document.getElementById('addressNodeLink');
                if (!/^\d+$/.test(val)) {
                    if (linkDiv) linkDiv.innerHTML = '';
                    return;
                }
                const url = `https://api.openstreetmap.org/api/0.6/node/${val}`;
                const resp = await fetch(url);
                if (!resp.ok) {
                    if (linkDiv) linkDiv.textContent = 'OSM node not found';
                    return;
                }
                const text = await resp.text();
                const parser = new DOMParser();
                const xml = parser.parseFromString(text, 'application/xml');
                const node = xml.querySelector('node');
                if (!node) return;
                const tags = {};
                node.querySelectorAll('tag').forEach(t => {
                    tags[t.getAttribute('k')] = t.getAttribute('v');
                });
                // Build parts
                const part1 = (tags['addr:street'] ? tags['addr:street'] : '') + (tags['addr:housenumber'] ? (tags['addr:street'] ? ' ' : '') + tags['addr:housenumber'] : '');
                const part2 = tags['addr:place'] ? tags['addr:place'] : '';
                const part3 = ((tags['addr:postcode'] ? tags['addr:postcode'] : '') + (tags['addr:city'] ? (tags['addr:postcode'] ? ' ' : '') + tags['addr:city'] : '')).trim();
                const parts = [];
                if (part1) parts.push(part1);
                if (part2) parts.push(part2);
                if (part3) parts.push(part3);
                if (parts.length === 0) {
                    if (linkDiv) linkDiv.textContent = 'No addr:* tags';
                    return;
                }
                const label = parts.join(', ');
                if (linkDiv) linkDiv.innerHTML = `<a href="#" onclick="document.getElementById('address').value=\'${escapeHtml(label).replace(/'/g, "\\'")}\'; updateQuickStatements(); return false;">Load address: ${escapeHtml(label)}</a>`;
            } catch (err) {
                // ignore
            }
        }

        function populateSelectOptions(selectElement, options) {
            for (let value in options) {
                let option = document.createElement('option');
                option.value = value;
                option.text = options[value];
                selectElement.add(option);
            }
        }

        function copyToClipboard() {
            let quickStatements = document.getElementById('quickStatements');
            quickStatements.select();
            quickStatements.setSelectionRange(0, 99999); // For mobile devices
            document.execCommand('copy');

            let notification = document.getElementById('copyNotification');
            notification.style.display = 'block';
            setTimeout(() => {
                notification.style.display = 'none';
            }, 2000);
        }

        function updateNameSplitSuggestion() {
            const label = document.getElementById('label').value.trim();
            const container = document.getElementById('nameSplitSuggestion');
            if (!label) {
                container.innerHTML = '';
                return;
            }
            const parts = label.split(/\s+/);
            if (parts.length < 2) {
                container.innerHTML = '';
                return;
            }
            let html = '<b>Split full name:</b> ';
            for (let i = 0; i < parts.length; i++) {
                if (i > 0) {
                    let first = parts.slice(0, i).join(' ');
                    let sur = parts.slice(i).join(' ');
                    html += `<a href="#" onclick="setNameSplit('${first.replace(/'/g, "\\'")}', '${sur.replace(/'/g, "\\'")}'); return false;" style="text-decoration:none; font-size:18px; vertical-align:middle;" title='Split here'>âœ‚</a> `;
                }
                html += parts[i];
                if (i < parts.length - 1) html += ' ';
            }
            container.innerHTML = html;
        }

        function setNameSplit(first, sur) {
            document.getElementById('firstName').value = first;
            document.getElementById('surname').value = sur;
            lookupNameParts('firstName');
            lookupNameParts('surname');
        }

        // Wait for DOMContentLoaded before adding event listener
        document.addEventListener('DOMContentLoaded', function () {
            var labelInput = document.getElementById('label');
            if (labelInput) {
                labelInput.addEventListener('blur', updateNameSplitSuggestion);
            }
            updateNameSplitSuggestion();
        });
    </script>
</head>

<body>
    <h1>Wikidata Auto</h1>
    <form>
        <label for="label">Danish Label:</label>
        <input type="text" id="label" name="label" oninput="updateQuickStatements()" size="50"><br><br>

        <label for="description">Danish Description:</label>
        <input type="text" id="description" name="description" oninput="updateQuickStatements()" size="50"><br><br>

        <label for="alias">Danish Alias:</label>
        <input type="text" id="alias" name="alias" oninput="updateQuickStatements()" size="50"><br><br>

        <label for="type">Type:</label>
        <select id="type" name="type" onchange="updateSubTypeOptions()">
            <option value="Human">Human</option>
            <option value="Location">Location</option>
            <option value="Name">Name</option>
        </select><br><br>

        <label for="subType">Subtype:</label>
        <select id="subType" name="subType" onchange="updateSubtypeUI(); updateQuickStatements()">
            <!-- Options will be populated by JavaScript -->
        </select><br><br>

        <div id="humanFields" style="display: none;">
            <label for="citizenship">Citizenship (Kingdom of Denmark):</label>
            <input type="checkbox" id="citizenship" name="citizenship" onchange="updateQuickStatements()"
                checked><br><br>

            <label for="birthDate">Birth Date:</label>
            <input type="text" id="birthDate" name="birthDate" oninput="updateQuickStatements()"><br><br>

            <label for="deathDate">Death Date:</label>
            <input type="text" id="deathDate" name="deathDate" oninput="updateQuickStatements()"><br><br>

            <label for="occupation">Occupation:</label>
            <select id="occupation" name="occupation" onchange="updateQuickStatements()">
                <!-- Options will be populated by JavaScript -->
            </select><br><br>

            <label for="positionHeld">Position held:</label>
            <select id="positionHeld" name="positionHeld" onchange="updateQuickStatements()">
                <!-- Options will be populated by JavaScript -->
            </select><br>
            <div id="positionHeldDates" style="display:none;">
                <label for="positionStart">Start date:</label>
                <input type="text" id="positionStart" name="positionStart" oninput="updateQuickStatements()"><br>
                <label for="positionEnd">End date:</label>
                <input type="text" id="positionEnd" name="positionEnd" oninput="updateQuickStatements()"><br>
            </div><br>

            <label for="source">Source (Wikidata item or URL):</label>
            <input type="text" id="source" name="source" oninput="updateQuickStatements()"><br><br>

            <div id="nameSplitSuggestion" style="margin-bottom: 10px;"></div>
            <label for="firstName">First name:</label>
            <input type="text" id="firstName" name="firstName" oninput="lookupNameParts('firstName')"><br>
            <div id="firstNameResults"></div><br>

            <label for="surname">Surname:</label>
            <input type="text" id="surname" name="surname" oninput="lookupNameParts('surname')"><br>
            <div id="surnameResults"></div><br>
        </div>

        <div id="cityFields" style="display: none;">
            <label for="country">Country (Denmark):</label>
            <input type="checkbox" id="country" name="country" onchange="updateQuickStatements()" checked><br><br>

            <label for="municipality">Municipality:</label>
            <select id="municipality" name="municipality" onchange="updateQuickStatements()">
                <!-- Options will be populated by JavaScript -->
            </select><br><br>

            <label for="coordinates">Coordinates (P625):</label>
            <input type="text" id="coordinates" name="coordinates" oninput="updateQuickStatements()">
            <!-- <div id="osmCoordinateLink" style="margin-top:5px;"></div><br><br> -->
            <div id="osmCoordinateLink"></div><br>

            <div id="elevationField" style="display:none; margin-bottom:8px;">
                <label for="elevation">Elevation (meters, P2044):</label>
                <input type="text" id="elevation" name="elevation" oninput="updateQuickStatements()"
                    placeholder="e.g. 55.3">
            </div><br>

            <label for="address">Address (P6375):</label>
            <input type="text" id="address" name="address" oninput="updateQuickStatements(); scheduleFetchAddress()" size="50">
            <div id="addressNodeLink" style="margin-top:4px; color:#333; font-size:90%"></div><br><br>

            <label for="osmNode">OpenStreetMap Node ID (P11693):</label>
            <input type="text" id="osmNode" name="osmNode" oninput="updateQuickStatements(); scheduleFetchOSM('node')">
            <div id="osmNodeName" style="margin-top:4px; color:#333; font-size:90%"></div><br>

            <label for="osmWay">OpenStreetMap Way ID (P10689):</label>
            <input type="text" id="osmWay" name="osmWay" oninput="updateQuickStatements(); scheduleFetchOSM('way')">
            <div id="osmWayName" style="margin-top:4px; color:#333; font-size:90%"></div><br>

            <label for="osmRelation">OpenStreetMap Relation ID (P402):</label>
            <input type="text" id="osmRelation" name="osmRelation"
                oninput="updateQuickStatements(); scheduleFetchOSM('relation')">
            <div id="osmRelationName" style="margin-top:4px; color:#333; font-size:90%"></div><br>
        </div>

        <label for="quickStatements">QuickStatements:</label><br>
        <textarea id="quickStatements" name="quickStatements" rows="10" cols="50" readonly></textarea><br>
        <a href="#" onclick="copyToClipboard()">Copy to Clipboard</a>
        <div id="copyNotification" style="display: none; color: green;">Copied to clipboard!</div><br>
        <a id="quickStatementsLink" href="#" target="_blank" accesskey="a">Open in QuickStatements</a>
    </form>

    <script>
        // Initialize the form with default values
        updateSubTypeOptions();
        populateSelectOptions(document.getElementById('occupation'), occupations);
        populateSelectOptions(document.getElementById('positionHeld'), positionsHeld);
        populateSelectOptions(document.getElementById('municipality'), municipalities);
    </script>
</body>

</html>